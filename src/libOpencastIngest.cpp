#define LIBOPENCASTINGEST_COMPILE_HEADER_ALS_LIB
#include "libOpencastIngest.h"

#include <iostream>
#include <sstream>
#include <cstring>
#include <curl/curl.h>
#include <tinyxml2.h>

using std::string;

namespace libOpencastIngest
{

static size_t CurlWriteMemoryCallback(char * contents, size_t size, size_t nmemb, std::string * userp)
{
	size_t realsize = size * nmemb;

	userp->append(contents, realsize);

	return realsize;
}


static std::string createMediaPackage(
		const std::string & opencastInstanceUrl,
		libOpencastIngest_AuthType authType,
		const std::string & username,
		const std::string & password,
		const std::string & authCookie,
		const std::string & useragent,
		long * outCurlReturnCode,
		long * outHttpReturnCode)
{
	string dataBuffer{};
	// string headerBuffer{};

	string url = opencastInstanceUrl + "ingest/createMediaPackage";
	string auth = username + ":" + password;

	long httpCode = 0;

	// generated by:
	// "curl -i --digest -u "opencast_system_account:CHANGE_ME" -H "X-Requested-Auth: Digest" "http://localhost:8080/ingest/createMediaPackage" --libcurl -"
	// then modified
	CURLcode ret;
	CURL *hnd;
	struct curl_slist *slist1;

	slist1 = NULL;

	hnd = curl_easy_init();
	curl_easy_setopt(hnd, CURLOPT_URL, url.c_str());
	curl_easy_setopt(hnd, CURLOPT_NOPROGRESS, 1L);

	// Authentication
	if (authType == LIBOPENCASTINGEST_DIGESTAUTH)
	{
		slist1 = curl_slist_append(slist1, "X-Requested-Auth: Digest");
		curl_easy_setopt(hnd, CURLOPT_HTTPAUTH, (long) CURLAUTH_DIGEST);
		curl_easy_setopt(hnd, CURLOPT_USERPWD, auth.c_str());
	}
	else if (authType == LIBOPENCASTINGEST_BASICAUTH)
	{
		curl_easy_setopt(hnd, CURLOPT_USERPWD, auth.c_str());
	}
	else if (authType == LIBOPENCASTINGEST_COOKIEAUTH)
	{
		curl_easy_setopt(hnd, CURLOPT_COOKIE, authCookie.c_str());
	}

	curl_easy_setopt(hnd, CURLOPT_USERAGENT, useragent.c_str());
	curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, slist1);
	curl_easy_setopt(hnd, CURLOPT_MAXREDIRS, 50L);
	curl_easy_setopt(hnd, CURLOPT_HTTP_VERSION, (long)CURL_HTTP_VERSION_2TLS);
	curl_easy_setopt(hnd, CURLOPT_TCP_KEEPALIVE, 1L);

	curl_easy_setopt(hnd, CURLOPT_WRITEDATA, &dataBuffer);
	curl_easy_setopt(hnd, CURLOPT_WRITEFUNCTION, CurlWriteMemoryCallback);

#ifdef _WIN32
	curl_easy_setopt(hnd, CURLOPT_SSL_ENABLE_ALPN, 0);
#endif

	// curl_easy_setopt(hnd, CURLOPT_HEADERDATA, &headerBuffer);
	// curl_easy_setopt(hnd, CURLOPT_HEADERFUNCTION, CurlWriteMemoryCallback);

	/* Here is a list of options the curl code used that cannot get generated
	*  as source easily. You may select to either not use them or implement
	*  them yourself.
	*
	* CURLOPT_WRITEDATA set to a objectpointer
	* CURLOPT_WRITEFUNCTION set to a functionpointer
	* CURLOPT_READDATA set to a objectpointer
	* CURLOPT_READFUNCTION set to a functionpointer
	* CURLOPT_SEEKDATA set to a objectpointer
	* CURLOPT_SEEKFUNCTION set to a functionpointer
	* CURLOPT_ERRORBUFFER set to a objectpointer
	* CURLOPT_STDERR set to a objectpointer
	* CURLOPT_HEADERFUNCTION set to a functionpointer
	* CURLOPT_HEADERDATA set to a objectpointer
	*
	* */

	ret = curl_easy_perform(hnd);

	curl_easy_getinfo(hnd, CURLINFO_RESPONSE_CODE, &httpCode);

	curl_easy_cleanup(hnd);
	hnd = NULL;
	curl_slist_free_all(slist1);
	slist1 = NULL;

	// output error codes
	*outCurlReturnCode = ret;
	*outHttpReturnCode = httpCode;

	return dataBuffer;
}

static std::string addDCCatalog(
		const std::string & opencastInstanceUrl,
		libOpencastIngest_AuthType authType,
		const std::string & username,
		const std::string & password,
		const std::string & authCookie,
		const std::string & useragent,
		const std::string & flavor,
		const std::string & mediaPackage,
		const std::string & dublinCore,
		long * outCurlReturnCode,
		long * outHttpReturnCode)
{
	string url = opencastInstanceUrl + "ingest/addDCCatalog";
	string auth = username + ":" + password;

	string dataBuffer{};
	long httpCode = 0;

	// generated by:
	// "curl --digest -u "opencast_system_account:CHANGE_ME" -H "X-Requested-Auth: Digest" "http://localhost:8080/ingest/addDCCatalog" -F flavor="dublincore/episode" -F mediaPackage="mediaPackage" -F dublinCore="dublinCore" --libcurl -"
	// then modified

	CURLcode ret;
	CURL *hnd;
	struct curl_httppost *post1;
	struct curl_httppost *postend;
	struct curl_slist *slist1;

	post1 = NULL;
	postend = NULL;
	curl_formadd(&post1, &postend,
	       CURLFORM_COPYNAME, "flavor",
	       CURLFORM_COPYCONTENTS, flavor.c_str(),
	       CURLFORM_END);
	curl_formadd(&post1, &postend,
	       CURLFORM_COPYNAME, "mediaPackage",
	       CURLFORM_COPYCONTENTS, mediaPackage.c_str(),
	       CURLFORM_END);
	curl_formadd(&post1, &postend,
	       CURLFORM_COPYNAME, "dublinCore",
	       CURLFORM_COPYCONTENTS, dublinCore.c_str(),
	       CURLFORM_END);
	slist1 = NULL;

	hnd = curl_easy_init();
	curl_easy_setopt(hnd, CURLOPT_URL, url.c_str());
	curl_easy_setopt(hnd, CURLOPT_NOPROGRESS, 1L);

	// Authentication
	if (authType == LIBOPENCASTINGEST_DIGESTAUTH)
	{
		slist1 = curl_slist_append(slist1, "X-Requested-Auth: Digest");
		curl_easy_setopt(hnd, CURLOPT_HTTPAUTH, (long) CURLAUTH_DIGEST);
		curl_easy_setopt(hnd, CURLOPT_USERPWD, auth.c_str());
	}
	else if (authType == LIBOPENCASTINGEST_BASICAUTH)
	{
		curl_easy_setopt(hnd, CURLOPT_USERPWD, auth.c_str());
	}
	else if (authType == LIBOPENCASTINGEST_COOKIEAUTH)
	{
		curl_easy_setopt(hnd, CURLOPT_COOKIE, authCookie.c_str());
	}

	curl_easy_setopt(hnd, CURLOPT_HTTPPOST, post1);
	curl_easy_setopt(hnd, CURLOPT_USERAGENT, useragent.c_str());
	curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, slist1);
	curl_easy_setopt(hnd, CURLOPT_MAXREDIRS, 50L);
	curl_easy_setopt(hnd, CURLOPT_HTTP_VERSION, (long)CURL_HTTP_VERSION_2TLS);
	curl_easy_setopt(hnd, CURLOPT_TCP_KEEPALIVE, 1L);

	curl_easy_setopt(hnd, CURLOPT_WRITEDATA, &dataBuffer);
	curl_easy_setopt(hnd, CURLOPT_WRITEFUNCTION, CurlWriteMemoryCallback);

#ifdef _WIN32
	curl_easy_setopt(hnd, CURLOPT_SSL_ENABLE_ALPN, 0);
#endif


	ret = curl_easy_perform(hnd);

	curl_easy_getinfo(hnd, CURLINFO_RESPONSE_CODE, &httpCode);

	curl_easy_cleanup(hnd);
	hnd = NULL;
	curl_formfree(post1);
	post1 = NULL;
	curl_slist_free_all(slist1);
	slist1 = NULL;

	// output error codes
	*outCurlReturnCode = ret;
	*outHttpReturnCode = httpCode;

	return dataBuffer;
}

static std::string addTrack(
		const std::string & opencastInstanceUrl,
		libOpencastIngest_AuthType authType,
		const std::string & username,
		const std::string & password,
		const std::string & authCookie,
		const std::string & useragent,
		const std::string & flavor,
		const std::string & mediaPackage,
		const std::string & pathToTrack,
		long * outCurlReturnCode,
		long * outHttpReturnCode)
{

	string url = opencastInstanceUrl + "ingest/addTrack";
	string auth = username + ":" + password;

	string dataBuffer{};
	long httpCode = 0;

	// generated by:
	// "curl --digest -u "opencast_system_account:CHANGE_ME" -H "X-Requested-Auth: Digest" "http://localhost:8080/ingest/addTrack" -F flavor="dublincore/episode" -F mediaPackage="mediaPackage" -F "BODY=@video.mp4" --libcurl -"
	// then modified

	CURLcode ret;
	CURL *hnd;
	struct curl_httppost *post1;
	struct curl_httppost *postend;
	struct curl_slist *slist1;

	post1 = NULL;
	postend = NULL;
	curl_formadd(&post1, &postend,
	       CURLFORM_COPYNAME, "flavor",
	       CURLFORM_COPYCONTENTS, flavor.c_str(),
	       CURLFORM_END);
	curl_formadd(&post1, &postend,
	       CURLFORM_COPYNAME, "mediaPackage",
	       CURLFORM_COPYCONTENTS, mediaPackage.c_str(),
	       CURLFORM_END);
	curl_formadd(&post1, &postend,
	       CURLFORM_COPYNAME, "BODY",
	       CURLFORM_FILE, pathToTrack.c_str(),
	       CURLFORM_CONTENTTYPE, "application/octet-stream",
	       CURLFORM_END);
	slist1 = NULL;

	hnd = curl_easy_init();
	curl_easy_setopt(hnd, CURLOPT_URL, url.c_str());
	curl_easy_setopt(hnd, CURLOPT_NOPROGRESS, 1L);

	// Authentication
	if (authType == LIBOPENCASTINGEST_DIGESTAUTH)
	{
		slist1 = curl_slist_append(slist1, "X-Requested-Auth: Digest");
		curl_easy_setopt(hnd, CURLOPT_HTTPAUTH, (long) CURLAUTH_DIGEST);
		curl_easy_setopt(hnd, CURLOPT_USERPWD, auth.c_str());
	}
	else if (authType == LIBOPENCASTINGEST_BASICAUTH)
	{
		curl_easy_setopt(hnd, CURLOPT_USERPWD, auth.c_str());
	}
	else if (authType == LIBOPENCASTINGEST_COOKIEAUTH)
	{
		curl_easy_setopt(hnd, CURLOPT_COOKIE, authCookie.c_str());
	}

	curl_easy_setopt(hnd, CURLOPT_HTTPPOST, post1);
	curl_easy_setopt(hnd, CURLOPT_USERAGENT, useragent.c_str());
	curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, slist1);
	curl_easy_setopt(hnd, CURLOPT_MAXREDIRS, 50L);
	curl_easy_setopt(hnd, CURLOPT_HTTP_VERSION, (long)CURL_HTTP_VERSION_2TLS);
	curl_easy_setopt(hnd, CURLOPT_TCP_KEEPALIVE, 1L);

	curl_easy_setopt(hnd, CURLOPT_WRITEDATA, &dataBuffer);
	curl_easy_setopt(hnd, CURLOPT_WRITEFUNCTION, CurlWriteMemoryCallback);

#ifdef _WIN32
  // set ssl alpn to false, because curl 7.49.1 has a bug and doesn't support this on windows 7 and before
  // this curl version seems to be shipped with obs
	curl_easy_setopt(hnd, CURLOPT_SSL_ENABLE_ALPN, 0);
#endif


	ret = curl_easy_perform(hnd);

	curl_easy_getinfo(hnd, CURLINFO_RESPONSE_CODE, &httpCode);

	curl_easy_cleanup(hnd);
	hnd = NULL;
	curl_formfree(post1);
	post1 = NULL;
	curl_slist_free_all(slist1);
	slist1 = NULL;

	// output error codes
	*outCurlReturnCode = ret;
	*outHttpReturnCode = httpCode;

	return dataBuffer;
}

static std::string ingest(
		const std::string & opencastInstanceUrl,
		libOpencastIngest_AuthType authType,
		const std::string & username,
		const std::string & password,
		const std::string & authCookie,
		const std::string & useragent,
		const std::string & mediaPackage,
		const std::string & workflowId,
		long * outCurlReturnCode,
		long * outHttpReturnCode)
{
	string url = opencastInstanceUrl + "ingest/ingest/" + workflowId;
	string auth = username + ":" + password;

	string dataBuffer{};
	long httpCode = 0;

	// generated by:
	// "curl --digest -u "opencast_system_account:CHANGE_ME" -H "X-Requested-Auth: Digest" "http://localhost:8080/ingest/ingest/fast" -F mediaPackage="mediaPackage" --libcurl -"
	// then modified

	CURLcode ret;
	CURL *hnd;
	struct curl_httppost *post1;
	struct curl_httppost *postend;
	struct curl_slist *slist1;

	post1 = NULL;
	postend = NULL;
	curl_formadd(&post1, &postend,
	       CURLFORM_COPYNAME, "mediaPackage",
	       CURLFORM_COPYCONTENTS, mediaPackage.c_str(),
	       CURLFORM_END);
	slist1 = NULL;

	hnd = curl_easy_init();
	curl_easy_setopt(hnd, CURLOPT_URL, url.c_str());
	curl_easy_setopt(hnd, CURLOPT_NOPROGRESS, 1L);

	// Authentication
	if (authType == LIBOPENCASTINGEST_DIGESTAUTH)
	{
		slist1 = curl_slist_append(slist1, "X-Requested-Auth: Digest");
		curl_easy_setopt(hnd, CURLOPT_HTTPAUTH, (long) CURLAUTH_DIGEST);
		curl_easy_setopt(hnd, CURLOPT_USERPWD, auth.c_str());
	}
	else if (authType == LIBOPENCASTINGEST_BASICAUTH)
	{
		curl_easy_setopt(hnd, CURLOPT_USERPWD, auth.c_str());
	}
	else if (authType == LIBOPENCASTINGEST_COOKIEAUTH)
	{
		curl_easy_setopt(hnd, CURLOPT_COOKIE, authCookie.c_str());
	}

	curl_easy_setopt(hnd, CURLOPT_HTTPPOST, post1);
	curl_easy_setopt(hnd, CURLOPT_USERAGENT, useragent.c_str());
	curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, slist1);
	curl_easy_setopt(hnd, CURLOPT_MAXREDIRS, 50L);
	curl_easy_setopt(hnd, CURLOPT_HTTP_VERSION, (long)CURL_HTTP_VERSION_2TLS);
	curl_easy_setopt(hnd, CURLOPT_TCP_KEEPALIVE, 1L);

	curl_easy_setopt(hnd, CURLOPT_WRITEDATA, &dataBuffer);
	curl_easy_setopt(hnd, CURLOPT_WRITEFUNCTION, CurlWriteMemoryCallback);

#ifdef _WIN32
	curl_easy_setopt(hnd, CURLOPT_SSL_ENABLE_ALPN, 0);
#endif


	ret = curl_easy_perform(hnd);

	curl_easy_getinfo(hnd, CURLINFO_RESPONSE_CODE, &httpCode);

	curl_easy_cleanup(hnd);
	hnd = NULL;
	curl_formfree(post1);
	post1 = NULL;
	curl_slist_free_all(slist1);
	slist1 = NULL;

	// output error codes
	*outCurlReturnCode = ret;
	*outHttpReturnCode = httpCode;

	return dataBuffer;
}

// assumes basic DCCatalog, no error handling!
static void generateDCCatalog_ConditionalAddToXML(tinyxml2::XMLDocument & xml,
		const std::string & name, const std::string & content)
{
	if (content.length() > 0)
	{
		// create new elem
		tinyxml2::XMLElement * elem = xml.NewElement(name.c_str());
		elem->SetText(content.c_str());

		xml.RootElement()->InsertEndChild(elem);
	}

	return;
}

// assumes basic DCCatalog, no error handling!
static void generated_DCCatalog_AddCreatedField(tinyxml2::XMLDocument & xml,
		const std::string & created)
{
	if (created.length() > 0)
	{
		// create new elem
		tinyxml2::XMLElement * elem = xml.NewElement("dcterms:created");
		elem->SetAttribute("xsi:type", "dcterms:W3CDTF");
		elem->SetText(created.c_str());

		xml.RootElement()->InsertEndChild(elem);
	}

	return;
}

} // namespace libOpencastIngest


using namespace libOpencastIngest;

extern "C"
{

const char * libOpencastIngest_generateDCCatalog(
		const char * pCreated,
		const char * pTitle,
		const char * pSubject,
		const char * pDescription,
		const char * pLanguage,
		const char * pRights,
		const char * pLicense,
		const char * pSeriesId,
		const char * pPresenters,
		const char * pContributors)
{
	// toString
	string created{pCreated};
	string title{pTitle};
	string subject{pSubject};
	string description{pDescription};
	string language{pLanguage};
	string rights{pRights};
	string license{pLicense};
	string seriesId{pSeriesId};
	string presenters{pPresenters};
	string contributors{pContributors};

	// generate xml doc
	tinyxml2::XMLDocument xml{};

	// basis dublincore
	xml.Parse("<?xml version=\"1.0\" encoding=\"UTF-8\"?><dublincore xmlns=\"http://www.opencastproject.org/xsd/1.0/dublincore/\" xmlns:dcterms=\"http://purl.org/dc/terms/\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"></dublincore>");

	// add created
	generated_DCCatalog_AddCreatedField(xml, created);

	// add fields
	generateDCCatalog_ConditionalAddToXML(xml, "dcterms:title", title);
	generateDCCatalog_ConditionalAddToXML(xml, "dcterms:subject", subject);
	generateDCCatalog_ConditionalAddToXML(xml, "dcterms:description", description);
	generateDCCatalog_ConditionalAddToXML(xml, "dcterms:language", language);
	generateDCCatalog_ConditionalAddToXML(xml, "dcterms:rightsHolder", rights);
	generateDCCatalog_ConditionalAddToXML(xml, "dcterms:license", license);
	generateDCCatalog_ConditionalAddToXML(xml, "dcterms:isPartOf", seriesId);
	generateDCCatalog_ConditionalAddToXML(xml, "dcterms:creator", presenters);
	generateDCCatalog_ConditionalAddToXML(xml, "dcterms:contributor", contributors);


	// build string out of xml-doc
	tinyxml2::XMLPrinter p{};
	xml.Print(&p);
	string result{p.CStr()};

	// generate ret char
	char * ret = new char[result.length() + 1];
	strcpy(ret, result.c_str());
	return ret;
}

void libOpencastIngest_cleanup(const char * toCleanup)
{
	delete[] toCleanup;
}


// wrapped versions (c compatible usw.)


const char * libOpencastIngest_createMediaPackage(
		const char * pOpencastInstanceUrl,
		libOpencastIngest_AuthType pAuthType,
		const char * pUsername,
		const char * pPassword,
		const char * pAuthCookie,
		const char * pUseragent,
		long * outCurlReturnCode,
		long * outHttpReturnCode)
{
	string result = createMediaPackage(
			string{pOpencastInstanceUrl},
			pAuthType,
			string{pUsername},
			string{pPassword},
			string{pAuthCookie},
			string{pUseragent},
			outCurlReturnCode,
			outHttpReturnCode
			);

	char * ret = new char[result.length() + 1];
	strcpy(ret, result.c_str());
	return ret;
}

const char * libOpencastIngest_addDCCatalog(
		const char * pOpencastInstanceUrl,
		libOpencastIngest_AuthType pAuthType,
		const char * pUsername,
		const char * pPassword,
		const char * pAuthCookie,
		const char * pUseragent,
		const char * pFlavor,
		const char * pMediaPackage,
		const char * pDublinCore,
		long * outCurlReturnCode,
		long * outHttpReturnCode)
{
	string result = addDCCatalog(
			string{pOpencastInstanceUrl},
			pAuthType,
			string{pUsername},
			string{pPassword},
			string{pAuthCookie},
			string{pUseragent},
			string{pFlavor},
			string{pMediaPackage},
			string{pDublinCore},
			outCurlReturnCode,
			outHttpReturnCode
			);

	char * ret = new char[result.length() + 1];
	strcpy(ret, result.c_str());
	return ret;
}

const char * libOpencastIngest_addTrack(
		const char * pOpencastInstanceUrl,
		libOpencastIngest_AuthType pAuthType,
		const char * pUsername,
		const char * pPassword,
		const char * pAuthCookie,
		const char * pUseragent,
		const char * pFlavor,
		const char * pMediaPackage,
		const char * pPathToTrack,
		long * outCurlReturnCode,
		long * outHttpReturnCode)
{
	string result = addTrack(
			string{pOpencastInstanceUrl},
			pAuthType,
			string{pUsername},
			string{pPassword},
			string{pAuthCookie},
			string{pUseragent},
			string{pFlavor},
			string{pMediaPackage},
			string{pPathToTrack},
			outCurlReturnCode,
			outHttpReturnCode
			);

	char * ret = new char[result.length() + 1];
	strcpy(ret, result.c_str());
	return ret;
}

const char * libOpencastIngest_ingest(
		const char * pOpencastInstanceUrl,
		libOpencastIngest_AuthType pAuthType,
		const char * pUsername,
		const char * pPassword,
		const char * pAuthCookie,
		const char * pUseragent,
		const char * pMediaPackage,
		const char * pWorkflowId,
		long * outCurlReturnCode,
		long * outHttpReturnCode)
{
	string result = ingest(
			string{pOpencastInstanceUrl},
			pAuthType,
			string{pUsername},
			string{pPassword},
			string{pAuthCookie},
			string{pUseragent},
			string{pMediaPackage},
			string{pWorkflowId},
			outCurlReturnCode,
			outHttpReturnCode
			);

	char * ret = new char[result.length() + 1];
	strcpy(ret, result.c_str());
	return ret;
}

}
